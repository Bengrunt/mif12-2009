%{
#include <iostream>
#include "ListeIdentificateurs.hpp"
#include "TableDesIdentificateurs.hpp"
#include "TableDesSymboles.hpp"
#include "Program.hpp"
#include "Variable.hpp"
#include "TypeBoolean.hpp"
#include "TypeChar.hpp"
#include "TypeInteger.hpp"
#include "TypeReal.hpp"
#include "TypeString.hpp"
#include "TypePointer.hpp"
#include "TypeInterval.hpp"

/* Ressources définies dans le lexer.cpp. */
extern int yyerror(char* m);
extern int yylex();
extern FILE* yyin;
extern char* yytext;

TableDesIdentificateurs ti; /**< Table des indentificateurs. */
TableDesSymboles ts; /**< Table des symboles. */
%}
/* Mots clefs du langage */
%token KW_PROGRAM
%token KW_VAR
%token KW_BEGIN
%token KW_END
%token KW_INTEGER
%token KW_REAL
%token KW_BOOLEAN
%token KW_CHAR
%token KW_STRING
%token KW_ARRAY
%token KW_OF
%token KW_RECORD
%token KW_DIV
%token KW_MOD
%token KW_AND
%token KW_OR
%token KW_XOR
%token KW_NOT

/* Séparateurs du langage */
%token SEP_SCOL
%token SEP_DOT
%token SEP_COL
%token SEP_COMMA
%token SEP_DOTDOT
%token SEP_CO
%token SEP_CF
%token SEP_PO
%token SEP_PF


/* Opérateurs. */
%token OP_EQ
%token OP_NEQ
%token OP_LT
%token OP_LTE
%token OP_GT
%token OP_GTE
%token OP_ADD
%token OP_SUB
%token OP_MUL
%token OP_SLASH
%token OP_EXP
%token OP_PTR
%token OP_AFFECT

/* Element */
%token TOK_IDENT
%token TOK_INTEGER
%token TOK_REAL
%token TOK_PTR
%token TOK_STRING
%token TOK_CHAR

/* Point de départ */
%start Program

%union {
  Type* type;
  ListeIdentificateurs* li;
  TypeInterval::Boundary bound;
  TypeInterval* ti;
}

%type<type> Type
%type<li> ListIdent
%type<bound> NSInterBase
%type<bound> InterBase
%type<ti> InterType

%%
/* Programme */
Program			:	ProgramHeader SEP_SCOL Block SEP_DOT
				;

/* En-tête du programme */
ProgramHeader	:	KW_PROGRAM TOK_IDENT {
						try{ti.add(yytext);}
						catch(AllocationException e) {
							std::cerr << e.what() << std::endl;
							exit(EXIT_FAILURE);
						}
						ts.add(new Program());
					}
				;

/* Bloc de programme, procédure ou fonction */
Block			:	BlockDeclVar BlockCode
				;
/* Bloc de déclaration de constantes */
BlockDeclConst : KW_CONST ListDeclConst
               |
               ;

ListDeclConst  : ListDeclConst DeclConst
               | DeclConst
               ;

DeclConst      : TOK_IDENT OP_EQ Expression SEP_SCOL
               ;

/* Bloc de déclaration de variables */
BlockDeclVar 	:	KW_VAR ListDeclVar
				|
				;

/* Liste de déclaration de variables */		
ListDeclVar		:	ListDeclVar DeclVar
				|	DeclVar
				;

/* Bloc de déclaration de type utilisateur. */
BlockDeclType  : KW_TYPE ListDeclType
               |
               ;

ListDeclType   : ListDeclType DeclType
               | DeclType
               ;

DeclType       : TOK_IDENT OP_EQ Type SEP_SCOL
               ;

/* Déclaration de variables */
DeclVar			:	ListIdent SEP_COL Type SEP_SCOL {
						for(
							unsigned int i = 0;
							i < $1->size();
							i++
						) {
							try{ti.add($1->get(i));}
							catch(AllocationException e) {
								std::cerr << e.what() << std::endl;
								exit(EXIT_FAILURE);
							}
							ts.add(new Variable($3));
						}
						delete $1;
						$1 = NULL;
					}
				;

/* Liste d'identificateurs */
ListIdent		:	ListIdent SEP_COMMA TOK_IDENT {
						$$ = $1;
						try{$$->add(yytext);}
						catch(AllocationException e) {
							std::cerr << e.what() << std::endl;
							exit(EXIT_FAILURE);
						}
					}
				|	TOK_IDENT {
						$$ = new ListeIdentificateurs();
						try{$$->add(yytext);}
						catch(AllocationException e) {
							std::cerr << e.what() << std::endl;
							exit(EXIT_FAILURE);
						}
					}
				;

/* Type de base */
Type			:	KW_INTEGER      {$$ = new TypeInteger();}
                |	KW_REAL         {$$ = new TypeReal();}
                |	KW_BOOLEAN      {$$ = new TypeBoolean();}
                |	KW_CHAR         {$$ = new TypeChar();}
                |	KW_STRING       {$$ = new TypeString();}
				|	OP_PTR Type		{$$ = new TypePointer($2);}
				|   InterType		{$$ = $1;}
                ;

/* Intervalle. */
InterType      : InterBase SEP_DOTDOT InterBase	{$$ = new TypeInterval($1, $3);}
               ;
InterBase      : NSInterBase			{$$ = $1;}
               | OP_SUB NSInterBase		{$2.data.iVal = -$2.data.iVal; $$ = $2;}
               ;
NSInterBase    : TOK_IDENT		{$$.id = true; $$.data.id = ti.getId(yytext);}
               | TOK_INTEGER	{$$.id = false; $$.data.iVal = atoi(yytext);}
               | TOK_CHAR		{$$.id = false; $$.data.iVal = (int) yytext[1];}
			   ;

/* Bloc de code */
BlockCode		:	KW_BEGIN KW_END
                ;

%%

int main (int argc, char** argv) {
	/* Vérification arguments. */
	if(argc != 2) {
		std::cerr << "Erreur : Vous devez passer une source Pascal en argument." << std::endl;
		exit(EXIT_FAILURE);
	}
	
	yyin = fopen(argv[1], "r");
	if(yyin == NULL) {
		return EXIT_FAILURE;
	}
	
    yyparse();
	/*
	TypeInterval::Boundary min = {false, -6}, max = {false, 88};
	TypeInterval* i = new TypeInterval(min, max);
	char* result = i->getName();
	
	std::cout << "Test : " << result << std::endl;
	
	max.id = true;
	max.data.iVal = 777;
	i->setMaximum(max);
	result = i->getName();
	
	std::cout << "Test : " << result << std::endl;
	
	min.id = true;
	min.data.iVal = 786899873;
	i->setMinimum(min);
	result = i->getName();
	
	std::cout << "Test : " << result << std::endl;
	*/
	std::cout << "Table des identificateurs : ----------------------------------------------------" << std::flush;
	ti.print();
	std::cout << "Table des symboles : -----------------------------------------------------------" << std::flush;
	ts.print();
	
    fclose(yyin);
	
	return EXIT_SUCCESS;
}
